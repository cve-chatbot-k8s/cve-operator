/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	b64 "encoding/base64"
	"fmt"
	monitorv1 "github.com/csye7125-su24-team7/cve-operator/api/v1"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// GitHubReleaseReconciler reconciles a GitHubRelease object
type GitHubReleaseReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

//var(
//	configMapName string
//	namespace string
//)

// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleases,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleases/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleases/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GitHubRelease object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleaseReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)
	log.Info("Reconciling GitHubRelease")

	// Fetch the GitHubRelease CR instance
	var release monitorv1.GitHubRelease
	if err := r.Get(ctx, req.NamespacedName, &release); err != nil {
		log.Error(err, "unable to fetch GitHubRelease")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}
	release.Spec.SetDefaults()

	configMapName := fmt.Sprintf("%s-configmap", release.Name)
	release.SetNamespace("default")
	//namespace := release.Namespace
	// Define the ConfigMap
	//cfgMap := r.defineConfigMap(&release)

	// Check if the ConfigMap already exists if not create it
	//if err := r.Get(ctx, types.NamespacedName{Name: configMapName, Namespace: namespace}, cfgMap); err != nil {
	//	log.Error(err, "ConfigMap not created for Job")
	//
	//	log.V(1).Info("Creating ConfigMap")
	//	cfgMap_error := r.Create(ctx, cfgMap)
	//	if cfgMap_error != nil {
	//		log.Error(cfgMap_error, "Unable to create ConfigMap for Job")
	//		return ctrl.Result{}, cfgMap_error
	//	}
	//	log.V(1).Info("ConfigMap created successfully!")
	//	//return ctrl.Result{}, client.IgnoreNotFound(err)
	//}

	// CREATE: ImagePullSecrets
	//scrt := r.defineDockerSecret(&release)
	//if err := r.Get(ctx, types.NamespacedName{Name: scrt.Name, Namespace: namespace}, scrt); err != nil {
	//	log.Error(err, "Secret not created for Job")
	//
	//	log.V(1).Info("Creating Secret")
	//	scrt_error := r.Create(ctx, scrt)
	//	if scrt_error != nil {
	//		log.Error(scrt_error, "Unable to create Secret for CronJob")
	//		return ctrl.Result{}, scrt_error
	//	}
	//	log.V(1).Info("Secret created successfully!")
	//	//return ctrl.Result{}, client.IgnoreNotFound(err)
	//}

	// Define the job
	job := r.createJob(ctx, &release, configMapName, "scrt.Name")

	// Check if this Job already exists
	found := &batchv1.Job{}
	err := r.Get(ctx, types.NamespacedName{Name: job.Name, Namespace: job.Namespace}, found)
	if err != nil && errors.IsNotFound(err) {
		log.Info("Creating a new Job", "Job.Namespace", job.Namespace, "Job.Name", job.Name)
		err = r.Create(ctx, job)
		if err != nil {
			log.Error(err, "Failed to create new Job", "Job.Namespace", job.Namespace, "Job.Name", job.Name)
			return reconcile.Result{}, err
		}
		// Job created successfully - return and requeue
		return reconcile.Result{Requeue: true}, nil
	} else if err != nil {
		log.Error(err, "Failed to get Job")
		return reconcile.Result{}, err
	}

	if err := r.Get(ctx, types.NamespacedName{Name: job.Name, Namespace: job.Namespace}, job); err != nil {
		log.V(1).Info("Creating Job")
		err := r.Create(ctx, job)

		if err != nil {
			log.Error(err, "Error Creating Job")
		}
		log.V(2).Info("Job created", "req", req, "job", job)
		log.V(1).Info("Job created successfully!")
	}

	// Job already exists - check if it needs to be retried or if it has succeeded
	if found.Status.Succeeded > 0 {
		log.Info("Job has completed successfully", "Job.Namespace", found.Namespace, "Job.Name", found.Name)
		release.Status.Processed = true
		// Update GitHubRelease status here to indicate processing is complete
		// This prevents the job from being launched again for the same CR
		// Note: Implement the status update logic as per your CRD definition
	} else if found.Status.Failed > 0 {
		if release.Status.RetryCount < 4 {
			release.Status.RetryCount += 1
			return reconcile.Result{}, err
		}
		// Implement retry logic here if necessary
		// Note: Kubernetes Jobs have their own backoff limit for retries, which is sufficient for this use case
	}

	// the default domain for the finalizer is "finalizers.monitor.my.domain"
	githubReleaseFinalizer := "githubrelease.finalizers.monitor.my.domain"

	// Check if the GitHubRelease object is being deleted
	if release.ObjectMeta.DeletionTimestamp.IsZero() {
		// The object is not being deleted, so if it does not have our finalizer,
		// then let's add the finalizer and update the object. This is equivalent
		// to registering our finalizer.
		if !controllerutil.ContainsFinalizer(&release, githubReleaseFinalizer) {
			controllerutil.AddFinalizer(&release, githubReleaseFinalizer)
			if err := r.Update(ctx, &release); err != nil {
				return ctrl.Result{}, err
			}
		}
	} else {
		// The object is being deleted
		if controllerutil.ContainsFinalizer(&release, githubReleaseFinalizer) {
			// our finalizer is present, so lets delete all external dependency
			if err := r.deleteExternalResources(ctx, &release); err != nil {
				return ctrl.Result{}, err
			}
			// Remove our finalizer from the list and update it
			controllerutil.RemoveFinalizer(&release, githubReleaseFinalizer)
			if err := r.Update(ctx, &release); err != nil {
				return ctrl.Result{}, err
			}
		}
		// Stop reconciliation as the item is being deleted
		return ctrl.Result{}, nil
	}

	return ctrl.Result{}, nil
}

func (r *GitHubReleaseReconciler) defineConfigMap(release *monitorv1.GitHubRelease) *corev1.ConfigMap {
	configMapName := fmt.Sprintf("%s-configmap", release.Name)
	cfgMap := corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ConfigMap",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      configMapName,
			Namespace: "default",
		},
		Data: map[string]string{
			"CVE_URL": release.Spec.AssetURL,
			//"kafka.bootstrapServers": "kafka-broker-0.kafka-broker-headless.kafka.svc.cluster.local:9092,kafka-broker-1.kafka-broker-headless.kafka.svc.cluster.local:9092,kafka-broker-2.kafka-broker-headless.kafka.svc.cluster.local:9092",
			"KAFKA_BOOTSTRAP_SERVERS": release.Spec.KafkaBootstrapServers,
			"KAFKA_TOPIC":             release.Spec.KafkaTopic,
			"NAMESPACE":               release.Spec.KafkaNamespace,
			"DOCKER_CONFIG_JSON":      release.Spec.DockerConfigJSON,
		},
	}

	err := controllerutil.SetControllerReference(release, &cfgMap, r.Scheme)
	if err != nil {
		log.Log.Error(err, "Failed to set controller reference")
	}
	return &cfgMap
}

func (r *GitHubReleaseReconciler) createJob(ctx context.Context, release *monitorv1.GitHubRelease, cfgMapName string, secretName string) *batchv1.Job {
	// Define the job
	job := &batchv1.Job{
		ObjectMeta: metav1.ObjectMeta{
			Name:      release.Name + "-job",
			Namespace: "default",
		},
		Spec: batchv1.JobSpec{
			Template: corev1.PodTemplateSpec{
				Spec: corev1.PodSpec{
					RestartPolicy: corev1.RestartPolicyOnFailure,
					ImagePullSecrets: []corev1.LocalObjectReference{
						{
							Name: "cve-secret",
						},
					},
					Containers: []corev1.Container{
						{
							Name:            "producer-app",
							Image:           "girish332/webapp-cve-processor",
							ImagePullPolicy: corev1.PullAlways,
							EnvFrom: []corev1.EnvFromSource{
								{
									ConfigMapRef: &corev1.ConfigMapEnvSource{
										LocalObjectReference: corev1.LocalObjectReference{
											Name: "cve-config",
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}

	// Set GitHubRelease instance as the owner and controller
	controllerutil.SetControllerReference(release, job, r.Scheme)
	return job
}

// Delete the Job and its dependent resources
func (r *GitHubReleaseReconciler) deleteExternalResources(ctx context.Context, release *monitorv1.GitHubRelease) error {
	log := log.FromContext(ctx)
	jobName := release.Name + "-job"
	configMapName := release.Name + "-configMap"

	// Deleting Job
	job := &batchv1.Job{}
	if err := r.Get(ctx, types.NamespacedName{Name: jobName, Namespace: release.Namespace}, job); err != nil {
		log.Error(err, "Cannot fetch the Job")
		return err
	}

	log.Info("Job found and ready to delete")
	if err := r.Delete(ctx, job); err != nil {
		return err
	}
	log.Info("Successfully deleted Job!")

	// Deleting ConfigMap
	cfgMap := &corev1.ConfigMap{}
	if err := r.Get(ctx, types.NamespacedName{Name: configMapName, Namespace: release.Namespace}, cfgMap); err != nil {
		log.Error(err, "Cannot fetch the ConfigMap")
		return err
	}
	if err := r.Delete(ctx, cfgMap); err != nil {
		return err
	}
	log.Info("ConfigMap deleted successfully!")
	// Todo: Add Logic to delete dockerConfigJson secret

	// Deleting CronJob Secret
	//if err := r.Get(ctx, types.NamespacedName{Name: secret.Name, Namespace: release.Namespace}, secret); err != nil {
	//	log.Error(err, "Cannot fetch the Secret")
	//	return err
	//}
	//err_scrt := r.Delete(ctx, secret)
	//
	//if err_scrt != nil {
	//	log.Error(err_scrt, "Unable to delete Secret")
	//	return err_scrt
	//}
	return nil
}

func (r *GitHubReleaseReconciler) defineDockerSecret(release *monitorv1.GitHubRelease) *corev1.Secret {
	secretName := release.Name + "-dockersecret"
	decodedValue, _ := b64.StdEncoding.DecodeString(release.Spec.DockerConfigJSON)
	scrt := corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: release.Namespace,
		},
		Type: corev1.SecretTypeDockerConfigJson,
		StringData: map[string]string{
			".dockerconfigjson": string(decodedValue),
		},
	}

	controllerutil.SetControllerReference(release, &scrt, r.Scheme)
	return &scrt
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleaseReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&monitorv1.GitHubRelease{}).
		Owns(&batchv1.Job{}).
		Owns(&corev1.ConfigMap{}).
		Complete(r)
}
