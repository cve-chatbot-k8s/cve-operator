/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"

	monitorv1 "github.com/csye7125-su24-team7/cve-operator/api/v1"
	"github.com/google/go-github/v63/github"
	"golang.org/x/oauth2"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=monitor.my.domain,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	log := log.FromContext(ctx)
	log.Info("Reconciling GitHubReleasesMonitor")

	// Step 1: Fetch the GitHubReleasesMonitor CR instance
	var monitor monitorv1.GitHubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.Error(err, "unable to fetch GitHubReleasesMonitor")
		return ctrl.Result{}, err
	}

	monitor.Spec.SetDefaults()

	monitorFromTime, err := monitor.Spec.ValidateMonitorFrom()
	if err != nil {
		log.Error(err, "Invalid monitorFrom value")
		return ctrl.Result{}, err
	}

	var deltaAssetURLs []string

	if monitor.Spec.MonitorFrom == "now" {
		deltaAssetURLs, err = r.checkForReleases(ctx, &monitor, monitorFromTime)
		if err != nil {
			log.Error(err, "Unable to check for new releases")
		}
	} else {
		deltaAssetURLs, err = r.checkForReleasesDate(ctx, &monitor, monitorFromTime)
		if err != nil {
			log.Error(err, "Unable to check for new releases")
			return ctrl.Result{}, err
		}
	}

	for _, deltaAssetURL := range deltaAssetURLs {
		err = r.createGitHubRelease(ctx, &monitor, deltaAssetURL)
		if err != nil {
			log.Error(err, "Unable to create a new GithubRelease")
		}
	}

	monitor.Status.Releases = append(monitor.Status.Releases, deltaAssetURLs...)
	monitor.Status.LastChecked = metav1.Now()
	monitor.Status.MonitorFromTimestamp = metav1.NewTime(monitorFromTime)

	if err := r.Status().Update(ctx, &monitor); err != nil {
		log.Error(err, "Failed to update GitHubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	return ctrl.Result{RequeueAfter: time.Hour * 1}, nil
}

// Add a function to fetch releases from GitHub
func (r *GitHubReleasesMonitorReconciler) checkForReleases(ctx context.Context, monitor *monitorv1.GitHubReleasesMonitor, monitorFromTime time.Time) ([]string, error) {
	log := log.FromContext(ctx)
	// client := github.NewClient(nil)
	githubToken := os.Getenv("GITHUB_TOKEN")
	client := newGitHubClient(ctx, githubToken)

	owner, repo, err := r.parseGitHubURL(monitor.Spec.URL)
	if err != nil {
		log.Error(err, "Unable to parse githubURL")
		return []string{}, err
	}

	releases, _, err := client.Repositories.ListReleases(ctx, owner, repo, nil)
	if err != nil {
		log.Error(err, "Unable to list releases")
		return []string{}, err
	}

	var deltaAssetURL []string

	for _, release := range releases {
		if release.PublishedAt != nil && release.PublishedAt.After(monitorFromTime) {
			for _, asset := range release.Assets {
				if strings.Contains(asset.GetName(), "delta") {
					deltaAssetURL = append(deltaAssetURL, asset.GetBrowserDownloadURL())
				}
			}
		}
	}

	return deltaAssetURL, nil
}

// parseGitHubURL parses the GitHub URL and returns the owner and repository name.
func (r *GitHubReleasesMonitorReconciler) parseGitHubURL(gitHubURL string) (string, string, error) {
	parsedURL, err := url.Parse(gitHubURL)
	if err != nil {
		return "", "", err
	}

	// Split the path to get the owner and repo name
	parts := strings.Split(strings.Trim(parsedURL.Path, "/"), "/")
	if len(parts) < 2 {
		return "", "", fmt.Errorf("invalid GitHub URL: %s", gitHubURL)
	}

	owner := parts[0]
	repo := parts[1]
	return owner, repo, nil
}

func (r *GitHubReleasesMonitorReconciler) createGitHubRelease(ctx context.Context, monitor *monitorv1.GitHubReleasesMonitor, url string) error {
	log := log.FromContext(ctx)
	//releaseName := fmt.Sprintf("%s-%s", monitor.Name, monitor.Spec.MonitorFrom)
	timeStamp, _ := extractTimestampFromURL(url)
	releaseName := fmt.Sprintf("release-%s", timeStamp)

	// Check if the GitHubRelease CR already exists
	existingRelease := &monitorv1.GitHubRelease{}
	err := r.Get(ctx, types.NamespacedName{Name: releaseName, Namespace: monitor.ObjectMeta.Namespace}, existingRelease)
	if err == nil {
		log.Info("GitHubRelease already exists, skipping creation", "GitHubRelease.Namespace", existingRelease.Namespace, "GitHubRelease.Name", existingRelease.Name)
		return nil
	} else if !errors.IsNotFound(err) {
		log.Error(err, "Failed to get GitHubRelease")
		return err
	}

	newRelease := &monitorv1.GitHubRelease{
		ObjectMeta: metav1.ObjectMeta{
			Name:      releaseName,
			Namespace: monitor.ObjectMeta.Namespace,
		},
		Spec: monitorv1.GitHubReleaseSpec{
			AssetURL: url,
		},
	}

	if err := controllerutil.SetControllerReference(monitor, newRelease, r.Scheme); err != nil {
		return err
	}

	err = r.Create(ctx, newRelease)
	if err != nil {
		log.Error(err, "Failed to create GitHubRelease", "GitHubRelease.Namespace", newRelease.Namespace, "GitHubRelease.Name", newRelease.Name)
		return err
	}

	return nil
}

func extractTimestampFromURL(rawURL string) (string, error) {
	parsedURL, err := url.Parse(rawURL)
	if err != nil {
		return "", err
	}

	// Extract the filename from the URL path
	pathSegments := parsedURL.Path
	//filename := pathSegments[strings.LastIndex(pathSegments, "/")+1:]

	// Define the regex pattern to extract the timestamp
	re := regexp.MustCompile(`cve_\d{4}-\d{2}-\d{2}_\d{4}Z`)
	matches := re.FindStringSubmatch(pathSegments)
	if len(matches) == 0 {
		return "", fmt.Errorf("timestamp not found in filename")
	}

	// Extract the timestamp
	timestamp := matches[0]
	timestamp = strings.Replace(timestamp, "_", "-", -1)
	return strings.ToLower(timestamp), nil
}

func (r *GitHubReleasesMonitorReconciler) checkForReleasesDate(ctx context.Context, monitor *monitorv1.GitHubReleasesMonitor, monitorFromDate time.Time) ([]string, error) {
	log := log.FromContext(ctx)
	client := github.NewClient(nil)

	owner, repo, err := r.parseGitHubURL(monitor.Spec.URL)
	if err != nil {
		log.Error(err, "Unable to parse githubURL")
		return []string{}, err
	}

	var allReleases []*github.RepositoryRelease
	opt := &github.ListOptions{PerPage: 10}

	for {
		releases, resp, err := client.Repositories.ListReleases(ctx, owner, repo, opt)
		if err != nil {
			log.Error(err, "Unable to list releases")
			return []string{}, err
		}
		allReleases = append(allReleases, releases...)
		if resp.NextPage == 0 {
			break
		}
		opt.Page = resp.NextPage
	}

	deltaAssetURLs := []string{}

	for _, release := range allReleases {
		if release.PublishedAt != nil && release.PublishedAt.After(monitorFromDate) && strings.Contains(release.GetName(), "end_of_day") {
			for _, asset := range release.Assets {
				if strings.Contains(asset.GetName(), "delta") {
					deltaAssetURLs = append(deltaAssetURLs, asset.GetBrowserDownloadURL())
				}
			}
		}
	}

	return deltaAssetURLs, nil
}

// Create a new GitHub client with authentication
func newGitHubClient(ctx context.Context, token string) *github.Client {
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	tc := oauth2.NewClient(ctx, ts)
	return github.NewClient(tc)
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&monitorv1.GitHubReleasesMonitor{}).
		Complete(r)
}
